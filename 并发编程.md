

# 并发/并行  🌎

并发（concurrency）和并行（parallellism）是：

1. 解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
2. 解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
3. 解释三：并行是在多台处理器上同时处理多个任务。如 hadoop 分布式集群，并发是在一台处理器上“同时”处理多个任务。

所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

------

并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。

并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。

# 进程与线程  🌎

**进程（Process）** 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。

**线程（thread）** 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

# 线程  🌎

## 线程的实现

**使用内核线程实现**

直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口（轻量级进程LWP[light weight process]），轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。

**使用用户线程实现**

广义来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程，狭义上说是完成建立在用户空间的线程库上的系统不可感知的。

## 线程状态

1. 新建状态（New）：新创建了一个线程对象。
2. 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
3. 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
4. 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
   （一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。
   （二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
   （三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
5. 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

## 线程调度

协同式线程调度

线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。

抢占式线程调度

| 调度操作         | 操作目的               |
| ---------------- | ---------------------- |
| start()          | 启动线程               |
| getId()          | 获得线程ID             |
| getName()        | 获得线程名字           |
| getPriority()    | 获得优先权             |
| isAlive()        | 判断线程是否活动       |
| isDaemon()       | 判断是否守护线程       |
| getState()       | 获得线程状态           |
| sleep(long mill) | 休眠线程               |
| join()           | 等待线程结束           |
| yield()          | 放弃cpu使用权利        |
| interrupt()      | 中断线程               |
| currentThread()  | 获得正在执行的线程对象 |

## start/run

线程是在start 和run 中 哪个是就绪的状态

start

------

**start能被调用多次吗**

start不可以被调用多次

通过Thread实例的start()，一个Thread的实例只能产生一个线程。一个Thread的实例一旦调用start()方法，这个实例的started标记就标记为true，事实中不管这个线程后来有没有执行到底，只要调用了一次start()就再也没有机会运行了。

一个线程对象只能调用一次start方法.从new到等待运行是单行道,所以如果你对一个已经启动的线程对象再调用一次start方法的话,会产生:IllegalThreadStateException异常. 可以被重复调用的是run()方法。

------

Thread类中run()和start()方法的区别

run()方法: 在本线程内调用该Runnable对象的run()方法，可以重复多次调用；

start()方法: 启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个线程

------

supplement

start是异步线程，run是同步线程

run相当于主线程main,start是异步调用run



## wait/sleep

|            | wait                                                         | sleep                                             |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------- |
| 同步       | 只能在同步上下文中调用wait方法，否则或抛出IllegalMonitorStateException异常 | 不需要在同步方法或同步块中调用                    |
| 作用对象   | wait方法定义在Object类中，作用于对象本身                     | sleep方法定义在java.lang.Thread中，作用于当前线程 |
| 释放锁资源 | 是                                                           | 否                                                |
| 唤醒条件   | 其他线程调用对象的notify()或者notifyAll()方法                | 超时或者调用interrupt()方法体                     |
| 方法属性   | wait是实例方法                                               | sleep是静态方法                                   |

## notify/notifyAll

1、wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写。

2、wait()使当前线程阻塞，前提是 必须先获得锁，一般配合synchronized 关键字使用，即，一般在synchronized 同步代码块里使用 wait()、notify/notifyAll() 方法。

3、 由于 wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的。

当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。

只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。

也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程让其获得锁

4、wait() 需要被try catch包围，以便发生异常中断也可以使wait等待的线程唤醒。

5、notify 和wait 的顺序不能错，如果A线程先执行notify方法，B线程在执行wait方法，那么B线程是无法被唤醒的。

6、notify 和 notifyAll的区别

notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。

## 如何停止一个线程

- 正常执行完停止
- 强行stop
- interrupt,并不是真的被终止了,只是变成了终止状态,后面可以再操作它让它真的终止
- while(true)的线程直接修改标志位

# 线程本地保存  🌎

ThreadLocal 是线程本地存储，在每个线程中都创建了一个 ThreadLocalMap 对象，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。

经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有 Session 管理 等问题。

在线程池中使用 ThreadLocal 为什么可能导致内存泄露呢？
在线程池中线程的存活时间太长，往往都是和程序同生共死的，这样 Thread 持有的 ThreadLocalMap 一直都不会被回收，再加上 ThreadLocalMap 中的 Entry 对 ThreadLocal 是弱引用（WeakReference），所以只要 ThreadLocal 结束了自己的生命周期是可以被回收掉的。
Entry 中的 Value 是被 Entry 强引用的，即便 value 的生命周期结束了，value 也是无法被回收的，导致内存泄露。

线程池中，如何正确使用 ThreadLocal？
在 finally 代码块中手动清理 ThreadLocal 中的 value，调用 ThreadLocal 的 remove()方法。

# 守护进程  🌎

守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束

# 线程池  🌎

## 线程池有什么优点

降低资源消耗：重用存在的线程，减少对象创建销毁的开销。

提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。

提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。

综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。

## Executors的创建线程池

Executors的创建线程池的方法，创建出来的线程池都实现了ExecutorService接口。常用方法有以下几个：

a、newFiexedThreadPool(int Threads)：创建固定数目线程的线程池。

b、newCachedThreadPool()：创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果没有可用的线程，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。

c、newSingleThreadExecutor()创建一个单线程化的Executor。

d、newScheduledThreadPool(int corePoolSize)创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。

看起来功能还是比较强大的，又用到了工厂模式、又有比较强的扩展性，重要的是用起来还比较方便，如：

ExecutorService executor = Executors.newFixedThreadPool(nThreads) ;
即可创建一个固定大小的线程池。

但是为什么我说不建议大家使用这个类来创建线程池呢？

## **Executors存在什么问题**

在阿里巴巴Java开发手册中提到，使用Executors创建线程池可能会导致OOM(OutOfMemory ,内存溢出)，但是并没有说明为什么，那么接下来我们就来看一下到底为什么不允许使用Executors？

我们先来一个简单的例子，模拟一下使用Executors导致OOM的情况

```java
public class ExecutorsDemo {
    private static ExecutorService executor = Executors.newFixedThreadPool(15);
    public static void main(String[] args) {
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            executor.execute(new SubThread());
        }
    }
}
 
class SubThread implements Runnable {
    @Override
    public void run() {
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            //do nothing
        }
    }
}
```

通过指定JVM参数：-Xmx8m -Xms8m 运行以上代码，会抛出OOM:

> Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded
> at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue.java:416)
> at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1371)
> at com.hollis.ExecutorsDemo.main(ExecutorsDemo.java:16)

以上代码指出，ExecutorsDemo.java的第16行，就是代码中的executor.execute(new SubThread());。

## **Executors为什么存在缺陷**

通过上面的例子，我们知道了Executors创建的线程池存在OOM的风险，那么到底是什么原因导致的呢？我们需要深入Executors的源码来分析一下。

其实，在上面的报错信息中，我们是可以看出蛛丝马迹的，在以上的代码中其实已经说了，真正的导致OOM的其实是LinkedBlockingQueue.offer方法。

> Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded
> at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue.java:416)
> at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1371)
> at com.hollis.ExecutorsDemo.main(ExecutorsDemo.java:16)

翻看代码的话，也可以发现，其实底层确实是通过LinkedBlockingQueue实现的：

> public static ExecutorService newFixedThreadPool(int nThreads) {
>  return new ThreadPoolExecutor(nThreads, nThreads,
>                 0L, TimeUnit.MILLISECONDS,
>                 new LinkedBlockingQueue<Runnable>());


如果读者对Java中的阻塞队列有所了解的话，看到这里或许就能够明白原因了。

Java中的BlockingQueue主要有两种实现，分别是ArrayBlockingQueue 和 LinkedBlockingQueue。

ArrayBlockingQueue是一个用数组实现的有界阻塞队列，必须设置容量。

LinkedBlockingQueue是一个用链表实现的有界阻塞队列，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。

这里的问题就出在：**不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。**也就是说，如果我们不设置LinkedBlockingQueue的容量的话，其默认容量将会是Integer.MAX_VALUE。

而newFixedThreadPool中创建LinkedBlockingQueue时，并未指定容量。此时，LinkedBlockingQueue就是一个无边界队列，对于一个无边界队列来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。

上面提到的问题主要体现在newFixedThreadPool和newSingleThreadExecutor两个工厂方法上，并不是说newCachedThreadPool和newScheduledThreadPool这两个方法就安全了，这两种方式创建的最大线程数可能是Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致OOM。

## **创建线程池的正确姿势**

避免使用Executors创建线程池，主要是避免使用其中的默认实现，那么我们可以自己直接调用ThreadPoolExecutor的构造函数来自己创建线程池。在创建的同时，给BlockQueue指定容量就可以了。

```java
private static ExecutorService executor = new ThreadPoolExecutor(10, 10,
        60L, TimeUnit.SECONDS,
        new ArrayBlockingQueue(10));
```

这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出java.util.concurrent.RejectedExecutionException，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。

除了自己定义ThreadPoolExecutor外。还有其他方法。这个时候第一时间就应该想到开源类库，如apache和guava等。

作者推荐使用guava提供的ThreadFactoryBuilder来创建线程池。

```java
public class ExecutorsDemo {
 
    private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
        .setNameFormat("demo-pool-%d").build();
 
    private static ExecutorService pool = new ThreadPoolExecutor(5, 200,
        0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());
 
    public static void main(String[] args) {
 
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            pool.execute(new SubThread());
        }
    }
}
```



# 线程组  🌎

ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。

线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。

为什么不推荐使用线程组？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。

<!--通过线程池自带的方法进来发现有一个线程工厂实现类，里面使用到了线程组-->

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200624105840239.png" alt="image-20200624105840239" style="zoom:80%;" />

## 线程池核心参数

### keepAliveTime

1、线程为什么会空闲 2、线程为什么要退出

我们来举例说明：

核心线程数10，最大线程数30，keepAliveTime是3秒

随着任务数量不断上升，线程池会不断的创建线程，直到到达核心线程数10，就不创建线程了，

这时多余的任务通过加入阻塞队列来运行，

当超出阻塞队列长度+核心线程数时，

这时不得不扩大线程个数来满足当前任务的运行，这时就需要创建新的线程了（最大线程数起作用），上限是最大线程数30

那么超出核心线程数10并小于最大线程数30的可能新创建的这20个线程相当于是“借”的，如果这20个线程空闲时间超过keepAliveTime，就会被退出

我们来看开头提到的两个问题：

1、线程为什么会空闲

2、线程为什么要退出

答：

1、没有任务时线程就会空闲下来，在线程池中任务是任务（Runnale）线程是线程（Worker）

2、通常超出核心线程的线程是“借”的，也就是说超出核心线程的情况算是一种能够预见的异常情况，并且这种情况并不常常发生（如果常常发生，那我想你应该调整你的核心线程数了），所以这种不经常发生而创建的线程为了避免资源浪费就应该要退出

我们需要看一下java.util.concurrent.ThreadPoolExecutor#getTask源码来验证上面一段话的含义：

```java
int wc = workerCountOf(c);
// Are workers subject to culling? 是否屠宰workers
//当allowCoreThreadTimeOut为true或者当前任务数超过核心线程数时，timed为true
boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
……
try {
Runnable r = timed ?
workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ://如果timed为true说明worker有可能要被关闭，这里调用的代码含义：如果超过keepAliveTime纳秒还没取到任务，就返回null，后面会调用processWorkerExit把worker关闭
workQueue.take();//否则任务队列为空就阻塞在这里，直到任务队列再有任务
if (r != null)
return r;
```

10个核心线程会不会退出，由下面的参数决定：

allowCoreThreadTimeout：是否允许核心线程空闲退出，默认值为false

**当keepAliveTime设置为0时，是直接不等待退出**



## 线程池都有哪些状态

RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。
SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。
STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。
TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。
TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。

#  Executor 框架  🌎

什么是 Executor 框架？为什么使用 Executor 框架？

Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。

每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的，而且无限制的创建线程会引起应用程序内存溢出。

所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors 框架可以非常方便的创建一个线程池。

##  Java 中 Executor 和 Executors 的区别

Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。

Executor 接口对象能执行我们的线程任务。

ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。

使用 ThreadPoolExecutor 可以创建自定义线程池。

Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 get()方法获取计算的结果。

## submit/execute

接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。

返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有

异常处理：submit()方便Exception处理

![image-20200619172519253](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200619172519253.png)

1. execute(ForkJoinTask) 异步执行tasks，无返回值
2. invoke(ForkJoinTask) 有Join, tasks会被同步到主进程
3. submit(ForkJoinTask) 异步执行，且带Task返回值，可通过task.get 实现同步到主线程



## 线程池之ThreadPoolExecutor详解

Executors和ThreaPoolExecutor创建线程池的区别
《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险

Executors 各个方法的弊端：

newFixedThreadPool 和 newSingleThreadExecutor:
主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。

newCachedThreadPool 和 newScheduledThreadPool:
主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。

ThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定

## ThreadPoolExecutor构造函数

ThreadPoolExecutor 3 个最重要的参数：

- corePoolSize ：核心线程数，线程数定义了最小可以同时运行的线程数量。
- maximumPoolSize ：线程池中允许存在的工作线程的最大数量
- workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中。

ThreadPoolExecutor其他常见参数:

- keepAliveTime：线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；
- unit ：keepAliveTime 参数的时间单位。
- threadFactory：为线程池提供创建新线程的线程工厂
- handler ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略

ThreadPoolExecutor饱和策略

ThreadPoolExecutor 饱和策略定义:

如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:

- ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。
- ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。
- ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。
- ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。

举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）



# Java内存模型(JMM)  🌎

[Java线程] <----->[工作内存]<----->[save与load等操作]<----->主内存

[Java线程] <----->[工作内存]<----->[save与load等操作]<----->主内存

[Java线程] <----->[工作内存]<----->[save与load等操作]<----->主内存



## 工作内存与主内存之间的交互

| 操作   | 作用对象 | 解释                                                         |
| ------ | -------- | ------------------------------------------------------------ |
| lock   | 主内存   | 把一个变量标识为一条线程独占的状态                           |
| unlock | 主内存   | 把一个处于锁定状态的变量释放出来，释放后才可以被其他线程锁定 |
| read   | 主内存   | 把一个变量的值从主内存传输到线程工作内存中，以便load操作使用 |
| load   | 工作内存 | 把read操作从主内存中的搭配的变量值放入工作内存中             |
| use    | 工作内存 | 把工作内存中的一个变量的值传递给执行引擎<br />每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作 |
| assign | 工作内存 | 把一个从执行引擎接收到的值赋给工作内存的变量<br />每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 |
| store  | 工作内存 | 把工作内存中的一个变量的值传送到主内存中，以便write操作      |
| write  | 工作内存 | 把store操作从工作内存中得到的变量的值放入主内存的变量中      |



# CountDownLatch/CyclicBarrier

| CountDownLatch                                               | CyclicBarrier                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 减计数方式                                                   | 加计数方式                                                   |
| 计算为0时释放所有等待的线程                                  | 计数达到指定值时释放所有等待线程                             |
| 计数为0时，无法重置                                          | 计数达到指定值时，计数置为0重新开始                          |
| 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 |
| 不可重复利用                                                 | 可重复利用                                                   |



# AQS  🌎

## 1.什么是AQS

`AQS`全称抽象队列同步器（AbstractQuenedSynchronizer），它是一个可以用来实现线程同步的基础框架。当然，它不是我们理解的`Spring`这种框架，它是一个类，类名就是`AbstractQuenedSynchronizer`，如果我们想要实现一个能够完成线程同步的锁或者类似的同步组件，就可以在使用`AQS`来实现，因为它封装了线程同步的方式，我们在自己的类中使用它，就可以很方便的实现一个我们自己的锁。

## 2.如何使用AQS

`AQS`封装了很多方法，如获取独占锁，释放独占锁，获取共享锁，释放共享锁......我们可以通过在自己的实现的同步组件中调用`AQS`的这些方法来实现一个线程同步的功能。但是，根据`AQS`的名称也能够想到，我们不能直接创建`AQS`的对象，调用这些方法，因为`AQS`是一个抽象类，我们需要继承`AQS`，创建它的子类对象来使用它。在实际使用中，一般是在我们自己的类中，以内部类的方式继承`AQS`，然后在内部创建一个对象，在这个类内部使用，比如`ReentrantLock`中就是定义了一个抽象内部类`Sync`，继承`AQS`，然后定义了一个`NonfairSync`类，继承`Sync`，`NonfairSync`是一个**非公平锁**；同时又定义了一个`FairSync`类继承`Sync`，`FairSync`是一个**公平锁**。

> **公平锁**：多个线程按照申请锁的顺序去获得锁，后申请锁的线程需要排队，等它之前的线程获得锁并释放后，它才能获得锁；
>
> **非公平锁**：线程获得锁的顺序于申请锁的顺序无关，申请锁的线程可以直接尝试获得锁，谁抢到就是谁的；

 我们继承了`AQS`，就可以直接调用它的方法了吗？当然不是。`Java`中提供的抽象组件，都是帮我们写好了通用的部分，但是一些具体的部分，还需要我们自己实现。举个比较简单的例子，`Java`中对自定义类型数组的排序，可以直接调用工具类的`sort`方法，`sort`方法已经实现了排序的算法，但是其中的比较过程是抽象的，需要我们自己实现，所以我们一般需要提供一个比较器（Comparator），或者让自定义类实现`Comparable`接口。这就是**模板方法**设计模式。

> **模板方法**：在一个方法中实现了一个算法的流程，但是其中的一些步骤是抽象的，需要在子类中实现，或者具体使用时实现。模板方法可以提高算法的复用性，提供了算法的弹性，对于不同的需求，可以通用同一份代码。

 而`AQS`的实现就是封装了一系列的模板方法，包括获取锁、释放锁等，这些都是模板方法。这些方法中调用的一些方法并没有具体实现，需要使用者根据自己的需求，在子类中进行实现。下面我们就来看看`AQS`中的这些方法。

## 3.AQS中的方法

**AQS底层维护一个int类型的变量state来表示当前的同步状态，根据当前state的值，来判断当前释放处于锁定状态，或者是其他状态**。而`state`的每一个值具体是什么含义，是由我们自己实现的。我们继承`AQS`时，根据自己的需求，实现一些方法，其中就是通过修改`state`的值来维持同步状态。而关于`state`，主要有以下三个方法：

> state：比较常用，各种状态都可以用它，但是它更着重于一种心理状态或者物理状态。
> status：用在人的身上一般是其身份和地位，作“状态，情形”讲时，多指政治和商业。
>
> state倾向于condition，是一种延续性的状态。status常用于描述一个过程中的某阶段（phase），类似于C语言中枚举型变量某一个固定的值，这个值属于一个已知的集合。 

- **int getState() **：获取当前同步状态`state`的值；
- **void setState(int newState) **：设置当前同步状态`state`的值；
- **boolean compareAndSetState(int expect, int update) **：使用`CAS`设置当前同步状态的值，方法能够保证设置同步状态时的原子性；参数`expect`为`state`的预期旧值，而`update`是需要修改的新值，若设置成功，方法返回`true`，否则`false`；

接下来我们再看一看在继承`AQS`时，我们可以重写的方法：

![img](https://img2020.cnblogs.com/blog/1324014/202004/1324014-20200409221307219-647175220.png)

![img](https://img2020.cnblogs.com/blog/1324014/202004/1324014-20200409221316455-184372984.png)

以上这些方法将会在`AQS`的模板方法中被调用，我们根据自己的需求，重写上述方法，控制同步状态`state`的值，即可控制线程同步的方式。下面再来看看`AQS`提供的模板方法：

![img](https://img2020.cnblogs.com/blog/1324014/202004/1324014-20200409221327546-1654915227.png)

`AQS`提供的模板方法主要分为三类：

- 独占式地获取和释放锁；
- 共享式地获取和释放锁；
- 查询`AQS`的同步队列中正在等待的线程情况；

  下面我们就来具体说一说`AQS`是如何实现线程同步的

前面提过，`AQS`通过一个`int`类型的变量`state`来记录当前的同步状态，也可以理解为锁的状态，根据`state`的值的不同，可以判断当前锁是否已经被获取。就拿独占锁来说，若我们要实现的是一个独占锁，则锁被获取后，其他线程将无法获取锁，需要进入阻塞状态，等待锁被释放。而线程获取锁就是通过修改`state`的值来实现的，一个线程修改`state`成功，则表示它成功获得了锁；若失败，则表示已经有其他线程获得了锁，则它需要进入阻塞状态。下面我们就来聊一聊`AQS`如何实现维持多个线程等待的。

  首先说明结论：**AQS通过一个同步队列来维护当前获取锁失败，进入阻塞状态的线程**。这个同步队列是一个双向链表，获取锁失败的线程会被封装成一个链表节点，加入链表的尾部排队，而`AQS`保存了链表的头节点的引用`head`以及链表的尾节点引用`tail`。这个同步队列如下所示：

![img](https://img2020.cnblogs.com/blog/1324014/202004/1324014-20200409221335438-280248331.png)

  在这个同步队列中，每个节点对应一个线程，每个节点都有一个`next`指针指向它的下一个节点，以及一个`prev`指针指向它的上一个节点。队列中的头节点`head`就是当前已经获取了锁，正在执行的线程对应的节点；而之后的这些节点，则对应着获取锁失败，正在排队的线程。

  当一个线程获取锁失败，它会被封装成一个`Node`，加入同步队列的尾部排队，同时线程会进入阻塞状态。也就是说，在同步队列中，除了头节点对应的线程是运行状态，其余的线程都是等待睡眠状态。而当头节点对应的线程释放锁时，它会唤醒它的下一个节点（也就是上图中的第二个节点），被唤醒的节点对应的线程开始尝试获取锁，若获取成功，它就会将自己置为`head`，然后将原来的`head`移出队列。接下来我们就通过源码，具体分析一下`AQS`的实现过程。

## 4.独占锁的获取与释放过程

### **（1）获取锁的实现**

  `AQS`的锁功能齐全，它既可以用来实现独占锁，也可以用来实现共享锁。

> **独占锁**：也叫排他锁，即锁只能由一个线程获取，若一个线程获取了锁，则其他想要获取锁的线程只能等待，直到锁被释放。比如说写锁，对于写操作，每次只能由一个线程进行，若多个线程同时进行写操作，将很可能出现线程安全问题；
>
> **共享锁**：锁可以由多个线程同时获取，锁被获取一次，则锁的计数器+1。比较典型的就是读锁，读操作并不会产生副作用，所以可以允许多个线程同时对数据进行读操作，而不会有线程安全问题，当然，前提是这个过程中没有线程在进行写操作；

 我们首先分析一下独占锁。在`AQS`中，通过方法`acquire`来获取独占锁，`acquire`方法的代码如下：

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

上面的方法执行流程如下：

1. 首先调用`tryAcquire`尝试获取一次锁，若返回`true`，表示获取成功，则`acquire`方法将直接返回；若返回`false`，则会继续向后执行`acquireQueued`方法；
2. `tryAcquire`返回`false`后，将执行`acquireQueued`，但是这个方法传入的参数调用了`addWaiter`方法；
3. `addWaiter`方法的作用是将当前线封装成同步队列的节点，然后加入到同步队列的尾部进行排队，并返回此节点；
4. `addWaiter`方法执行完成后，将它的返回值作为参数，调用`acquireQueued`方法。`acquireQueued`方法的作用是让当前线程在同步队列中阻塞，然后在被其他线程唤醒时去获取锁；
5. 若线程被唤醒并成功获取锁后，将从`acquireQueued`方法中退出，同时返回一个`boolean`值表示当前线程是否被中断，若被中断，则会执行下面的`selfInterrupt`方法，响应中断；

下面我们就来具体分析这个方法中调用的几个方法的执行流程。首先第一个`tryAcquire`方法：

```java
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}
```

  可以看到，这个方法的实现仅仅只是抛出了一个异常。我们之前提过，`AQS`是基于模板方法设计模式实现的，在其中定义了许多模板方法，在模板方法中会调用一些没有实现的方法，这些方法需要使用者根据自己的需求实现。而`acquire`方法就是一个模板方法，其中调用的`tryAcquire`方法就是需要我们自己实现的方法。`tryAcquire`的作用就是尝试修改`state`值，也就是获取锁，若修改成功，则返回`true`，否则返回`false`。它的实现需要根据`AQS`的子类具体分析，比如`ReentrantLock`中的`Sync`，这里我就不详细叙述了，后面写一篇专门讲`ReentrantLock`的博客。下面来看看`addWaiter`的源码：

```java
// 将线程封装成一个节点，放入同步队列的尾部
private Node addWaiter(Node mode) {
    // 当前线程封装成同步队列的一个节点Node
    Node node = new Node(Thread.currentThread(), mode);
    // 这个节点需要插入到原尾节点的后面，所以我们在这里先记下原来的尾节点
    Node pred = tail;
    // 判断尾节点是否为空，若为空表示队列中还没有节点，则不执行以下步骤
    if (pred != null) {
        // 记录新节点的前一个节点为原尾节点
        node.prev = pred;
        // 将新节点设置为新尾节点，使用CAS操作保证了原子性
        if (compareAndSetTail(pred, node)) {
            // 若设置成功，则让原来的尾节点的next指向新尾节点
            pred.next = node;
            return node;
        }
    }
    // 若以上操作失败，则调用enq方法继续尝试(enq方法见下面)
    enq(node);
    return node;
}

private Node enq(final Node node) {
    // 使用死循环不断尝试
    for (;;) {
        // 记录原尾节点
        Node t = tail;
        // 若原尾节点为空，则必须先初始化同步队列，初始化之后，下一次循环会将新节点加入队列
        if (t == null) { 
            // 使用CAS设置创建一个默认的节点作为首届点
            if (compareAndSetHead(new Node()))
                // 首尾指向同一个节点
                tail = head;
        } else {
            // 以下操作与addWaiter方法中的if语句块内一致
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

以上就是`addWaiter`方法的实现过程，我在代码中使用注释对每一步进行了详细的解析，它的执行过程大致可以总结为：**将新线程封装成一个节点，加入到同步队列的尾部，若同步队列为空，则先在其中加入一个默认的节点，再进行加入；若加入失败，则使用死循环（也叫自旋）不断尝试，直到成功为止**。这个过程中使用`CAS`保证了添加节点的原子性。下面看看`acquireQueued`方法的源码：

```java
/**
 * 让线程不间断地获取锁，若线程对应的节点不是头节点的下一个节点，则会进入等待状态
 * @param node the node
 */
final boolean acquireQueued(final Node node, int arg) {
    // 记录失败标志
    boolean failed = true;
    try {
        // 记录中断标志，初始为true
        boolean interrupted = false;
        // 循环执行，因为线程在被唤醒后，可能再次获取锁失败，需要重写进入等待
        for (;;) {
            // 获取当前线程节点的前一个节点
            final Node p = node.predecessor();
            // 若前一个节点是头节点，则tryAcquire尝试获取锁，若获取成功，则执行if中的代码
            if (p == head && tryAcquire(arg)) {
                // 将当前节点设置为头节点
                setHead(node);
                // 将原来的头节点移出同步队列
                p.next = null; // help GC
                // 失败标志置为false
                failed = false;
                // 返回中断标志，acquire方法可以根据返回的中断标志，判断当前线程是否被中断
                return interrupted;
            }
            // shouldParkAfterFailedAcquire方法判断当前线程是否能够进入等待状态，
            // 若当前线程的节点不是头节点的下一个节点，则需要进入等待状态，
            // 在此方法内部，当前线程会找到它的前驱节点中，第一个还在正常等待或执行的节点，
            // 让其作为自己的直接前驱，然后在需要时将自己唤醒（因为其中有些线程可能被中断），
            // 若找到，则返回true，表示自己可以进入等待状态了；
            // 则继续调用parkAndCheckInterrupt方法，当前线程在这个方法中等待，
            // 直到被其他线程唤醒，或者被中断后返回，返回时将返回一个boolean值，
            // 表示这个线程是否被中断，若为true，则将执行下面一行代码，将中断标志置为true
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        // 上面代码中只有一个return语句，且return的前一句就是failed = false;
        // 所以只有当异常发生时，failed才会保持true的状态运行到此处；
        // 异常可能是线程被中断，也可能是其他方法中的异常，
        // 比如我们自己实现的tryAcquire方法
        // 此时将取消线程获取锁的动作，将它从同步队列中移除
        if (failed)
            cancelAcquire(node);
    }
}
```

  以上就是`acquireQueued`方法的源码分析。这个方法的作用可以概括为：**让线程在同步队列中阻塞，直到它成为头节点的下一个节点，被头节点对应的线程唤醒，然后开始获取锁，若获取成功才会从方法中返回**。这个方法会返回一个`boolean`值，表示这个正在同步队列中的线程是否被中断。

  到此，获取独占锁的实现就分析完毕了。需要注意的是，这些过程中使用的`compareAndSetXXX`这种形式的方法，都是基于`CAS`机制实现的，保证了这些操作的原子性。

### **（2）释放锁的实现**

  分析完获取独占锁的代码后，我们再来看看释放锁的实现。释放独占锁是通过`release`方法实现的：

```java
public final boolean release(int arg) {
    // 调用tryRelease尝试修改state释放锁，若成功，将返回true，否则false
    if (tryRelease(arg)) {
        // 若修改state成功，则表示释放锁成功，需要将当前线程移出同步队列
        // 当前线程在同步队列中的节点就是head，所以此处记录head
        Node h = head;
        // 若head不是null，且waitStatus不为0，表示它是一个装有线程的正常节点，
        // 在之前提到的addWaiter方法中，若同步队列为空，则会创建一个默认的节点放入head
        // 这个默认的节点不包含线程，它的waitStatus就是0，所以不能释放锁
        if (h != null && h.waitStatus != 0)
            // 若head是一个正常的节点，则调用unparkSuccessor唤醒它的下一个节点所对应的线程
            unparkSuccessor(h);
        // 释放成功
        return true;
    }
    // 释放锁失败
    return false;
}
```

以上就是同步队列中头节点对应的线程释放锁的过程。`release`也是一个模板方法，其中通过调用`tryRelease`尝试释放锁，而`tryRelease`也需要使用者自己实现。在之前也说过，头节点释放锁时，需要唤醒它的下一个节点对应的线程，让这个线程不再等待，去获取锁，而这个过程就是通过`unparkSuccessor`方法实现的。

## 5.共享锁的获取与释放过程

 前面提到过，`AQS`不仅仅可以用来实现独占锁，还可以用来实现共享锁，下面我们就来看看`AQS`中，有关共享锁的模板方法的实现。首先是获取共享锁的实现，在`AQS`中，定义了`acquireShared`方法用来获取共享锁：

```java
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)
        doAcquireShared(arg);
}
```

  可以看到，这个方法比较简短。首先调用`tryAcquireShared`方法尝试获取一次共享锁，即修改`state`的值，若返回值`>=0`，则表示获取成功，线程不受影响，继续向下执行；若返回值小于`0`，表示获取共享锁失败，则线程需要进入到同步队列中等待，调用`doAcquireShared`方法。`acquireShared`方法也是`AQS`的一个模板方法，而其中的`tryAcquireShared`方法就是需要使用者自己实现的方法。下面我们来看看`doAcquireShared`方法的实现：

```java
/**
 * 不间断地获取共享锁，若线程对应的节点不是头节点的下一个节点，将进入等待状态
 * 实现与acquireQueued非常类似
 * @param arg the acquire argument
 */
private void doAcquireShared(int arg) {
    // 往同步队列的尾部添加一个默认节点，Node.SHARED是一个Node常量，
    // 它的值就是一个不带任何参数的Node对象，也就是new Node();
    final Node node = addWaiter(Node.SHARED);
    // 失败标志，默认为true
    boolean failed = true;
    try {
        // 中断标志，用来判断线程在等待的过程中释放被中断
        boolean interrupted = false;
        // 死循环不断尝试获取共享锁
        for (;;) {
            // 获取默认节点的前一个节点
            final Node p = node.predecessor();
            // 判断当前节点的前一个节点是否为head节点
            if (p == head) {
                // 尝试获取共享锁
                int r = tryAcquireShared(arg);
                // 若r>0，表示获取成功
                if (r >= 0) {
                    // 当前线程获取锁成功后，调用setHeadAndPropagate方法将当前线程设置为head
                    // 同时，若共享锁还能被其他线程获取，则在这个方法中也会向后传递，唤醒后面的线程
                    setHeadAndPropagate(node, r);
                    // 将原来的head的next置为null
                    p.next = null; // help GC
                    // 判断当前线程是否中断，若被中断，则调用selfInterrupt方法响应中断
                    if (interrupted)
                        selfInterrupt();
                    // 失败标志置为false
                    failed = false;
                    return;
                }
            }
            // 以下代码和获取独占锁的acquireQueued方法相同，即让当前线程进入等待状态
            // 具体解析可以看上面acquireQueued方法的解析
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

`doAcquireShared`方法的实现和获取独占锁中的`acquireQueued`方法很类似，但是主要有一点不同，那就是**线程在被唤醒后，若成功获取到了共享锁，还需要判断共享锁是否还能被其他线程获取，若可以，则继续向后唤醒它的下一个节点对应的线程**。下面再看看释放共享锁的代码，释放共享锁时通过方法`releaseShared`：

```java
public final boolean releaseShared(int arg) {
    // 尝试修改state的值释放锁
    if (tryReleaseShared(arg)) {
        // 若成功，则调用以下方法唤醒后继节点中的线程
        doReleaseShared();
        return true;
    }
    return false;
}
```

`releaseShared`也是一个模板方法，它通过调用使用者自己实现的`tryReleaseShared`方法尝试释放锁，修改`state`的值，若返回`true`，表示修改成功，则继续向下调用`doReleaseShared`唤醒`head`的下一个节点对应的线程，让它开始尝试获取锁；若修改`state`失败，则返回`false`。

## 6.使用AQS实现一个锁

 介绍完上面的内容，下面我们就来基于`AQS`实现一个自己的同步器，或者说锁。我们需要实现的锁要求如下：

> 实现一个锁，它是一个共享锁，但是每次至多支持两个线程同时获取锁，若当前已经有两个线程获取了锁，则其他获取锁的线程需要等待。

实现代码如下：

```java
/**
 * 抽象队列同步器（AQS）使用：
 *      实现一个同一时刻至多只支持两个线程同时执行的同步器
 */

// 让当前类继承Lock接口
public class TwinLock implements Lock {

    // 定义锁允许的最大线程数
    private final static int DEFAULT_SYNC_COUNT = 2;
    // 创建一个锁对象，用以进行线程同步，Sync继承自AQS
    private final Sync sync = new Sync(DEFAULT_SYNC_COUNT);

    // 以内部类的形式实现一个同步器类，也就是锁，这个锁继承自AQS
    private static final class Sync extends AbstractQueuedSynchronizer {

        // 构造方法中指定锁支持的线程数量
        Sync(int count) {
            // 若count小于0，则默认为2
            if (count <= 0) {
                count = DEFAULT_SYNC_COUNT;
            }
            // 设置初始同步状态
            setState(count);
        }
        
        /**
         * 重写tryAcquireShared方法，这个方法用来修改同步状态state，也就是获取锁
         */
        @Override
        protected int tryAcquireShared(int arg) {
            // 循环尝试
            for (; ; ) {
                // 获取当前的同步状态
                int nowState = getState();
                // 计算当前线程获取锁后，新的同步状态
                // 注意这里使用了减法，因为此时的state表示的是还能支持多少个线程
                // 而当前线程如果获得了锁，则state就要减小
                int newState = nowState - arg;
                
                // 如果newState小于0，表示当前已经没有剩余的资源了
                // 则当前线程不能获取锁，此时将直接返回小于0的newState；
                // 或者newState>0，就会执行compareAndSetState方法修改state的值，
                // 若修改成功将，将返回大于0的newState；
                // 若修改失败，则表示有其他线程也在尝试修改state，此时循环一次后，再次尝试
                if (newState < 0 || compareAndSetState(nowState, newState)) {
                    return newState;
                }
            }
        }

        /**
         * 尝试释放同步状态
         */
        @Override
        protected boolean tryReleaseShared(int arg) {
            for (; ; ) {
                // 获取当前同步状态
                int nowState = getState();
                // 计算释放后的新同步状态，这里使用加法，
                // 表示有线程释放锁后，当前锁可以支持的线程数量增加了
                int newState = nowState + arg;
                // 使用CAS修改同步状态，若成功则返回true，否则自旋
                if (compareAndSetState(nowState, newState)) {
                    return true;
                }
            }
        }
        
    }


    /**
     * 获取锁的方法
     */
    @Override
    public void lock() {
        // 这里调用的是AQS的模板方法acquireShared，
        // 在acquireShared中将调用我们重写的tryAcquireShared方法
        // 传入参数为1表示当前线程，当前线程获取锁后，state将-1
        sync.acquireShared(1);
    }

    /**
     * 解锁
     */
    @Override
    public void unlock() {
        // 这里调用的是AQS的模板方法releaseShared，
        // 在acquireShared中将调用我们重写的tryReleaseShared方法
        // 传入参数为1表示当前线程，当前线程释放锁后，state将+1
        sync.releaseShared(1);
    }

    /*******************其他需要实现的方法省略***************************/

}
```

 以上就实现了一个支持两个线程同时允许的共享锁，下面我们通过一个测试代码来测试效果：

```java
public static void main(String[] args) throws InterruptedException {
	// 创建一个我们自定义的锁对象
    Lock lock = new TwinLock();

    // 启动10个线程去尝试获取锁
    for (int i = 0; i < 10; i++) {
        Thread t = new Thread(()->{
            // 循环执行
            while (true) {
                // 获取锁
                lock.lock();
                try {
                    // 休眠1秒
                    Thread.sleep(1000);
                    // 输出线程名称
                    System.out.println(Thread.currentThread().getName());
                    // 再次休眠一秒
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    // 释放锁
                    lock.unlock();
                }
            }
        });
		// 将线程设置为守护线程，主线程结束后，收获线程自动结束
        t.setDaemon(true);
        t.start();
    }

	// 主线程每隔1秒输出一个分割行
    for (int i = 0; i < 10; i++) {
        Thread.sleep(1000);
        System.out.println("********************************");
    }
}
```

以上测试代码运行后，在每两个分割行之间，最多不会输出超过两个线程的名称，线程名称的输出将会以两个一队出现。我的输出结果如下：

```java

********************************
Thread-1
Thread-0
********************************
********************************
Thread-2
Thread-1
********************************
********************************
Thread-2
Thread-1
********************************
********************************
Thread-2
Thread-3
********************************
********************************
Thread-3
Thread-4
********************************

```

## 7.AQS如何实现线程等待

在研究`AQS`的过程中，我一直有这个疑惑——`AQS`如何让线程阻塞，直到最后才知道有一个叫`LockSupport`的工具类。这个工具类定义了很多静态方法，当需要让一个阻塞，或者唤醒一个线程时，就可以调用这个类中的方法，它的底层实现是通过一个`sun.misc.Unsafe`类的对象，`unsafe`类的方法都是本地方法，由其他语言实现，这个类是给不支持地址操作的`Java`，提供的一个操作内存地址的后门。

  `AQS`中通过以下两个方法来阻塞和唤醒线程：

- **LockSupport.park()**：阻塞当前线程；
- **LockSupport.unpark(Thread thread)**：将参数中传入的线程唤醒；

  前面讲解`AQS`的代码中，用到了方法`unparkSuccessor`，它的主要作用就是唤醒当前节点的下一个节点对应的线程，我们可以看看它的部分实现：

```java
private void unparkSuccessor(Node node) {

    // ...........省略其他代码............
    
    // 以下代码即为唤醒当前节点的下一个节点对应的线程
    Node s = node.next;
    if (s != null)
        LockSupport.unpark(s.thread);	// 使用LockSupport
}
```

# CountDownLatch  🌎

## 1.是什么

CountDownLatch是JDK提供的一个同步工具，它可以让一个或多个线程等待，一直等到其他线程中执行完成一组操作。

## 2.有哪些常用的方法

有`countDown`方法和`await`方法，CountDownLatch在初始化时，需要指定用给定一个整数作为计数器。当调用`countDown`方法时，计数器会被减1；当调用`await`方法时，如果计数器大于0时，线程会被阻塞，一直到计数器被`countDown`方法减到0时，线程才会继续执行。计数器是无法重置的，当计数器被减到0时，调用`await`方法都会直接返回。

## 3.调用countDown方法时，线程也会阻塞吗

不会的，调用`countDown`的线程可以继续执行，不需要等待计数器被减到0，只是调用await方法的线程需要等待。

## 4.使用案例

比如张三、李四和王五几个人约好去饭店一起去吃饭，这几个人都是比较绅士，要等到所有人都到齐以后才让服务员上菜。这种场景就可以用到CountDownLatch

**张三、李四和王五的顾客类**

```java
package onemore.study;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Random;
import java.util.concurrent.CountDownLatch;

public class Customer implements Runnable {
    private CountDownLatch latch;
    private String name;

    public Customer(CountDownLatch latch, String name) {
        this.latch = latch;
        this.name = name;
    }

    @Override
    public void run() {
        try {
            SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss.SSS");
            Random random = new Random();

            System.out.println(sdf.format(new Date()) + " " + name + "出发去饭店");
            Thread.sleep((long) (random.nextDouble() * 3000) + 1000);
            System.out.println(sdf.format(new Date()) + " " + name + "到了饭店");
            latch.countDown();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**服务员类**

```java
package onemore.study;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.CountDownLatch;

public class Waitress implements Runnable {
    private CountDownLatch latch;
    private String name;

    public Waitress(CountDownLatch latch, String name) {
        this.latch = latch;
        this.name = name;
    }

    @Override
    public void run() {
        try {
            SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss.SSS");
            System.out.println(sdf.format(new Date()) + " " + name  + "等待顾客");
            latch.await();
            System.out.println(sdf.format(new Date()) + " " + name  + "开始上菜");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**测试类**

```java
package onemore.study;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;

public class CountDownLatchTester {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3);

        List<Thread> threads = new ArrayList<>(3);
        threads.add(new Thread(new Customer(latch, "张三")));
        threads.add(new Thread(new Customer(latch, "李四")));
        threads.add(new Thread(new Customer(latch, "王五")));
        for (Thread thread : threads) {
            thread.start();
        }

        Thread.sleep(100);
        new Thread(new Waitress(latch, "♥小芳♥")).start();

        for (Thread thread : threads) {
            thread.join();
        }
    }
}
```

**运行结果**

```
15:25:53.015 王五出发去饭店
15:25:53.015 李四出发去饭店
15:25:53.015 张三出发去饭店
15:25:53.062 ♥小芳♥等待顾客
15:25:54.341 张三到了饭店
15:25:54.358 李四到了饭店
15:25:56.784 王五到了饭店
15:25:56.784 ♥小芳♥开始上菜
```

可以看到，服务员小芳在调用`await`方法时一直阻塞着，一直等到三个顾客都调用了`countDown`方法才继续执行

**如果有一个顾客迟迟没到，饭店都打样了，也不能一直等啊，应该这么办？**

可以使用`await`方法的另一个重载，传入等待的超时时间，比如服务员只等3秒钟，可以把服务员类中的

```java
latch.await();
```

改成

```java
latch.await(3, TimeUnit.SECONDS);
```

运行结果可能是这样的

```
17:24:40.915 张三出发去饭店
17:24:40.915 李四出发去饭店
17:24:40.915 王五出发去饭店
17:24:40.948 ♥小芳♥等待顾客
17:24:43.376 李四到了饭店
17:24:43.544 王五到了饭店
17:24:43.951 ♥小芳♥开始上菜
17:24:44.762 张三到了饭店
```

可以看到，服务员小芳在调用`await`方法时虽然被阻塞了，但是时间超过3秒后，没等顾客张三调用`countDown`方法就继续执行开始上菜了

## 5.实现原理

CountDownLatch有一个内部类叫做Sync，它继承了AbstractQueuedSynchronizer类，其中维护了一个整数`state`，并且保证了修改`state`的可见性和原子性。

创建CountDownLatch实例时，也会创建一个Sync的实例，同时把计数器的值传给Sync实例，具体是这样的：

```java
public CountDownLatch(int count) {
    if (count < 0) throw new IllegalArgumentException("count < 0");
    this.sync = new Sync(count);
}
```

在`countDown`方法中，只调用了Sync实例的`releaseShared`方法，具体是这样的：

```java
public void countDown() {
    sync.releaseShared(1);
}
```

其中的`releaseShared`方法，先对计数器进行减1操作，如果减1后的计数器为0，唤醒被await方法阻塞的所有线程，具体是这样的：

```java
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) { //对计数器进行减一操作
        doReleaseShared();//如果计数器为0，唤醒被await方法阻塞的所有线程
        return true;
    }
    return false;
}
```

其中的`tryReleaseShared`方法，先获取当前计数器的值，如果计数器为0时，就直接返回；如果不为0时，使用CAS方法对计数器进行减1操作，具体是这样的：

```java
protected boolean tryReleaseShared(int releases) {
    for (;;) {//死循环，如果CAS操作失败就会不断继续尝试。
        int c = getState();//获取当前计数器的值。
        if (c == 0)// 计数器为0时，就直接返回。
            return false;
        int nextc = c-1;
        if (compareAndSetState(c, nextc))// 使用CAS方法对计数器进行减1操作
            return nextc == 0;//如果操作成功，返回计数器是否为0
    }
}
```

在`await`方法中，只调用了Sync实例的`acquireSharedInterruptibly`方法，具体是这样的：

```java
public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
```

其中`acquireSharedInterruptibly`方法，判断计数器是否为0，如果不为0则阻塞当前线程，具体是这样的：

```java
public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) < 0)//判断计数器是否为0
        doAcquireSharedInterruptibly(arg);//如果不为0则阻塞当前线程
}
```

其中`tryAcquireShared`方法，是AbstractQueuedSynchronizer中的一个模板方法，其具体实现在Sync类中，其主要是判断计数器是否为零，如果为零则返回1，如果不为零则返回-1，具体是这样的

```java
protected int tryAcquireShared(int acquires) {
    return (getState() == 0) ? 1 : -1;
}
```

# CyclicBarrier  🌎



## CountDownLatch底层实现

## CyclicBarrier底层实现

# synchronized   🌎

## synchronized锁原理



## 怎么使用 synchronized 关键字

synchronized关键字最主要的三种使用方式：

修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁

```java
public class SyncTest implements Runnable{
    //共享资源变量
    int count = 0;

    @Override
    public synchronized void run() {
        for (int i = 0; i < 5; i++) {
            increaseCount();
            System.out.println(Thread.currentThread().getName()+":"+count++);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        SyncTest syncTest1 = new SyncTest();
//        SyncTest syncTest2 = new SyncTest();
        Thread thread1 = new Thread(syncTest1,"thread1");
        Thread thread2 = new Thread(syncTest1, "thread2");
        thread1.start();
        thread2.start();
    }
}
```

```java
public class SyncTest implements Runnable{
    //共享资源变量
    int count = 0;

    @Override
    public synchronized void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName()+":"+count++);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        SyncTest syncTest1 = new SyncTest();
        SyncTest syncTest2 = new SyncTest();
        Thread thread1 = new Thread(syncTest1,"thread1");
        Thread thread2 = new Thread(syncTest2, "thread2");
        thread1.start();
        thread2.start();
    }
}
```

修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。

```java
public class SyncTest implements Runnable {
    //共享资源变量
    static int count = 0;

    @Override
    public synchronized void run() {
        increaseCount();
    }

    private synchronized static void increaseCount() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + ":" + count++);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        SyncTest syncTest1 = new SyncTest();
        SyncTest syncTest2 = new SyncTest();
        Thread thread1 = new Thread(syncTest1, "thread1");
        Thread thread2 = new Thread(syncTest2, "thread2");
        thread1.start();
        thread2.start();
    }
}
```

修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

```java
public class SyncTest implements Runnable {
    //共享资源变量
    static int count = 0;
    private byte[] mBytes = new byte[0];

    @Override
    public synchronized void run() {
        increaseCount();
    }

    private void increaseCount() {
        //假设省略了其他操作的代码。
        //……………………
        synchronized (this) {
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + ":" + count++);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        SyncTest syncTest1 = new SyncTest();
        SyncTest syncTest2 = new SyncTest();
        Thread thread1 = new Thread(syncTest1, "thread1");
        Thread thread2 = new Thread(syncTest2, "thread2");
        thread1.start();
        thread2.start();
    }
}
```

总结： 

1. 对于实例同步方法，锁是当前实例对象。
2. 对于静态同步方法，锁是当前对象的class对象。
3. 对于同步方法块，锁是synchonized括号里配置的对象。

------

synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。

synchronized 关键字加到实例方法上是给对象实例上锁。

尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！

# Lock  🌎



# reentranLock   🌎

## 可重入锁reentranLock

原理AQS..

## 读写锁



# 死锁  🌎

## 如何防止死锁

有三种方式：加锁顺序、加锁时限、死锁检测

## 1.加锁顺序

当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。
如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。

Thread 1:
lock A
lock B

Thread 2:
wait for A
lock C (when A locked)

Thread 3:
wait for A
wait for B
wait for C

一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。

例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(译者注：获取锁A是获取锁C的必要条件)。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。

按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(并对这些锁做适当的排序)，但总有些时候是无法预知的。

## 2.加锁时限

另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行
(加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。

## 3.死锁检测

死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。

每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。
当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。
例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。

## 4.复杂情况

当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。
那么当检测出死锁时，这些线程该做些什么呢？

一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。

一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。



# volatile  🌎

**volatile**是java虚拟机提供的最轻量级的同步机制(关键字)

保证了可见性，有序性，不保证原子性

## 保证可见性

> 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值

CPU的缓存一致性协议MESI

## 保证有序性

内存屏障-禁止指令重排

内存屏障还是happens-before的volatile变量规则

## 不保证原子性

通过jmm+缓存一致性协议进行研究





# 分布式  🌎

![img](https://bkimg.cdn.bcebos.com/pic/5bafa40f4bfbfbed9c15b19b72f0f736aec31f81?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U5Mg==,xp_5,yp_5)

C(Consistency)

一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）

A(Availability)

可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）

P(Partition tolerance)

分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

因为任何分布式的架构，都必须保证P，所以只能从C和A中选择一个 





# 分布式锁  🌎

- 互斥性：任意时刻只能有一个客户端拥有锁，不能同时多个客户端获取
- 安全性：锁只能被持有该锁的用户删除，而不能被其他用户删除
- 死锁：获取锁的客户端因为某些原因而宕机，而未能释放锁，其他客户端无法获取此锁，需要有机制来避免该类问题的发生
- 容错：当部分节点宕机，客户端仍能获取锁或者释放锁

## 1.基于数据库

基于数据库实现排他锁

![img](https://img-blog.csdn.net/2018061414253488?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1emhpd2VpNTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

对method_name做了唯一性约束(unique key)，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功

但是这样做有很多缺点：

1. 这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。
2. 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。
3. 这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁
4. 就要再次触发获得锁操作。
   这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。

## 2.基于Redis

### 2.1.基本redis自身

加锁实际上就是在redis中，给Key键设置一个值，为避免死锁，并给定一个过期时间。

```shell
SET lock_key random_value NX PX 5000
```

值得注意的是：
 `random_value` 是客户端生成的唯一的字符串。
 `NX` 代表只在键不存在时，才对键进行设置操作。
 `PX 5000` 设置键的过期时间为5000毫秒。

这样，如果上面的命令执行成功，则证明客户端获取到了锁。

------

但是Java代码段

1.需要设置key并且设置超时时间(无法保证原子性)

```java
//该程序存在危险，如果执行到第二行就崩溃了，则此时key会被一直占用而无法被释放
RedisService redisService = SpringUtils.getBean(Redi sService.class); 
long status = redisService.setnx(key, "1");
if(status == 1) {
	redisService.expire(key, expire);
	//执行独占资源逻辑
	doOcuppiedWork();
}
```



### 2.2.基于jedis

加锁的过程很简单，就是通过SET指令来设置值，成功则返回；否则就循环等待，在timeout时间内仍未获取到锁，则获取失败。

方法1

```java
public class RedisTool {
    private static final String LOCK_SUCCESS = "OK";
    private static final String SET_IF_NOT_EXIST = "NX";
    private static final String SET_WITH_EXPIRE_TIME = "PX";

    /**
     * 尝试获取分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @param expireTime 超期时间
     * @return 是否获取成功
     */
    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {
        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);
        if (LOCK_SUCCESS.equals(result)) {
            return true;
        }
        return false;
    }
}
```

方法2

```java
public class RedisLock {
    Logger logger = LoggerFactory.getLogger(this.getClass());
    private String lock_key = "redis_lock"; //锁键
    protected long internalLockLeaseTime = 30000;//锁过期时间
    private long timeout = 999999; //获取锁的超时时间
    
    //SET命令的参数 
    SetParams params = SetParams.setParams().nx().px(internalLockLeaseTime);

    @Autowired
    JedisPool jedisPool;

    
    /**
     * 加锁
     * @param id
     * @return
     */
    public boolean lock(String id){
        Jedis jedis = jedisPool.getResource();
        Long start = System.currentTimeMillis();
        try{
            for(;;){
                //SET命令返回OK ，则证明获取锁成功
                String lock = jedis.set(lock_key, id, params);
                if("OK".equals(lock)){
                    return true;
                }
                //否则循环等待，在timeout时间内仍未获取到锁，则获取失败
                long l = System.currentTimeMillis() - start;
                if (l>=timeout) {
                    return false;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }finally {
            jedis.close();
        }
    }
}
```

解锁我们通过`jedis.eval`来执行一段LUA就可以。将锁的Key键和生成的字符串当做参数传进来

```java
    /**
     * 解锁
     * @param id
     * @return
     */
    public boolean unlock(String id){
        Jedis jedis = jedisPool.getResource();
        String script =
                "if redis.call('get',KEYS[1]) == ARGV[1] then" +
                        "   return redis.call('del',KEYS[1]) " +
                        "else" +
                        "   return 0 " +
                        "end";
        try {
            Object result = jedis.eval(script, Collections.singletonList(lock_key), 
                                    Collections.singletonList(id));
            if("1".equals(result.toString())){
                return true;
            }
            return false;
        }finally {
            jedis.close();
        }
    }
```

### 2.3.基于redisson

Redisson是架设在Redis基础上的一个Java驻内存数据网格（In-Memory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作

如上代码，就是加锁的全过程。先调用`tryAcquire`来获取锁，如果返回值ttl为空，则证明加锁成功，返回；如果不为空，则证明加锁失败。这时候，它会订阅这个锁的Channel，等待锁释放的消息，然后重新尝试获取锁。流程如下：

### 2.4.基于redLock

Redlock算法大概是这样的：

在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。我们确保将在N个实例上使用与在Redis单实例下相同方法获取和释放锁。现在我们假设有5个Redis master节点，分布在不同的机房尽量保证可用性。为了获得锁，client 会进行如下操作：

- 得到当前的时间，单位毫秒
- 尝试顺序地在 5 个实例上申请锁，当然需要使用相同的 key 和 random value，这里一个 client 需要合理设置与 master 节点沟通的 timeout 大小，避免长时间和一个 fail 了的节点浪费时间
- 当 client 在大于等于 3 个 master 上成功申请到锁的时候，且它会计算申请锁消耗了多少时间，这部分消耗的时间采用获得锁的当下时间减去第一步获得的时间戳得到，如果锁的持续时长（lock validity time）比流逝的时间多的话，那么锁就真正获取到了。
- 如果锁申请到了，那么锁真正的 lock validity time 应该是 origin（lock validity time） - 申请锁期间流逝的时间
- 如果 client 申请锁失败了，那么它就会在少部分申请成功锁的 master 节点上执行释放锁的操作，重置状态

当然，上面描述的只是获取锁的过程，而释放锁的过程比较简单：客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。

## 3.基于Zookeeper

Znode分为四种类型

**1.持久节点 （PERSISTENT）**

默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在 。

**2.持久节点顺序节点（PERSISTENT_SEQUENTIAL）**

所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号：

**3.临时节点（EPHEMERAL）**

和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除：

**4.临时顺序节点（EPHEMERAL_SEQUENTIAL）**

顾名思义，临时顺序节点结合和临时节点和顺序节点的特点：在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。

**Zookeeper分布式锁的原理**

Zookeeper分布式锁恰恰应用了**临时顺序节点**。具体如何实现呢？让我们来看一看详细步骤：

**获取锁**

首先，在Zookeeper当中创建一个持久节点ParentLock。当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个**临时顺序节点** Lock1。

![ãæ¯æ¥åäº«ãå¦ä½ç¨Zookeeperå®ç°åå¸å¼é](https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1Mjg1MTExMDY3NTcyODMzMzJmNTRi?x-oss-process=image/format,png)

之后，Client1查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。

![ãæ¯æ¥åäº«ãå¦ä½ç¨Zookeeperå®ç°åå¸å¼é](https://imgconvert.csdnimg.cn/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1Mjg1MTExMDY3NDNlY2Q1N2I4YzYz?x-oss-process=image/format,png)

这时候，如果再有一个客户端 Client2 前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock2。

![ãæ¯æ¥åäº«ãå¦ä½ç¨Zookeeperå®ç°åå¸å¼é](https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1Mjg1MTExMDY3NTQ1NGY4N2FlZjdk?x-oss-process=image/format,png)

Client2查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock2是不是顺序最靠前的一个，结果发现节点Lock2并不是最小的。

于是，Client2向排序仅比它靠前的节点Lock1注册Watcher，用于监听Lock1节点是否存在。这意味着Client2抢锁失败，进入了等待状态。

![ãæ¯æ¥åäº«ãå¦ä½ç¨Zookeeperå®ç°åå¸å¼é](https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1Mjg1MTExMDY3NDk1MWQ2MjljNWM1?x-oss-process=image/format,png)

这时候，如果又有一个客户端Client3前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock3。

![ãæ¯æ¥åäº«ãå¦ä½ç¨Zookeeperå®ç°åå¸å¼é](https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1Mjg1MTExMDY3NTlmZjFmZjMzNGM5?x-oss-process=image/format,png)

Client3查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock3是不是顺序最靠前的一个，结果同样发现节点Lock3并不是最小的。

于是，Client3向排序仅比它靠前的节点Lock2注册Watcher，用于监听Lock2节点是否存在。这意味着Client3同样抢锁失败，进入了等待状态。
这样一来，Client1得到了锁，Client2监听了Lock1，Client3监听了Lock2。这恰恰形成了一个等待队列，很像是Java当中ReentrantLock所依赖的

**释放锁**

释放锁分为两种情况：

**1.任务完成，客户端显示释放**

当任务完成时，Client1会显示调用删除节点Lock1的指令。

![ãæ¯æ¥åäº«ãå¦ä½ç¨Zookeeperå®ç°åå¸å¼é](https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1Mjg1MTExMDY4MDJiNDBmYTE5NzFj?x-oss-process=image/format,png)

**2.任务执行过程中，客户端崩溃**

获得锁的Client1在任务执行过程中，如果Duang的一声崩溃，则会断开与Zookeeper服务端的链接。根据临时节点的特性，相关联的节点Lock1会随之自动删除。

![ãæ¯æ¥åäº«ãå¦ä½ç¨Zookeeperå®ç°åå¸å¼é](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1Mjg1MTExMDY3MjkzNWRkZTg5ODMw?x-oss-process=image/format,png)

由于Client2一直监听着Lock1的存在状态，当Lock1节点被删除，Client2会立刻收到通知。这时候Client2会再次查询ParentLock下面的所有节点，确认自己创建的节点Lock2是不是目前最小的节点。如果是最小，则Client2顺理成章获得了锁。

![ãæ¯æ¥åäº«ãå¦ä½ç¨Zookeeperå®ç°åå¸å¼é](https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1Mjg1MTExMDY3MjBiNjgzNWI4YWZm?x-oss-process=image/format,png)

同理，如果Client2也因为任务完成或者节点崩溃而删除了节点Lock2，那么Client3就会接到通知。

![ãæ¯æ¥åäº«ãå¦ä½ç¨Zookeeperå®ç°åå¸å¼é](https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1Mjg1MTExMDY3Njc3YzYxM2NjZjI4?x-oss-process=image/format,png)

最终，Client3成功得到了锁。

也可以直接使用zookeeper第三方库Curator客户端，这个客户端中封装了一个可重入的锁服务。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODgzMzQwLzIwMTcxMi84ODMzNDAtMjAxNzEyMTUxNjI2NTQxNTItMTgxMDg2OTY4NS5wbmc?x-oss-process=image/format,png)

Curator提供的InterProcessMutex是分布式锁的实现。acquire方法用户获取锁，release方法用于释放锁。





# 分布式事务  🌎

## 1.分布式事务场景

- 1个微服务事务操作2个数据库
- 2个微服务操作一个数据库
- 2个(多个)微服务操作2个(多个)数据库

## 2.分布式事务解决方案

### 2.1全局事务JTA

### 2.2.可靠消息服务

### 2.3.最大努力通知 

### 2.4.TCC